第二章 程序的含义
==============

2.1 ”含义“的含义
--------------
> 程序员是注重实际的生物。程序员经常通过阅读文档、学习教程、研究现有的程序以及修 改自己的简单程序来学习新的编程语言，而不会过多地思考那些程序有什么含义。有时候，学习的过程就像试错:我们试图通过看例子和文档来理解一个语言片段，然后会努力用这种语言写点什么，之后所有问题就都爆发了，而我们只得回头重试，直到成功组装了一个大部分情况下都能工作的东西。随着程序支持的计算机和系统越来越复杂，它们很容易被看成是一些难懂的符咒，这些符咒只代表它们自己而看不出有什么含义，并且它们只是偶尔才能正常工作。

这是大多数人学习编程的方法，试错。当然作者没有就这种方式发表评价，只是说如何才能描述程序的含义。确定计算机程序含义的方法。我觉得那必然是语义咯。

>为了完整地定义编程语言，我们需要:语法，描述程序看起来是什么样的;语义，描述程序的含义。

通俗的解释了语法和语义。

>第三种方法是使用形式语义学中的数学方法准确描述编程语言的含义。它的目标是不仅能 用适合系统分析甚至自动化分析的格式写出规范，还能保证其完全没有歧义，这样就可以 对规范是否一致、是否含有冲突，以及是否有疏漏进行全面检查。在介绍如何处理语法之 后，我们将会看到语义规范的这些形式化方法。

如何描述编程语言的含义，除了解释器/编译器和官方规范外，就是使用形式语义学中的数学方法准确描述编程语言的含义。使用形式语义学中的方法描述出Rust语言的语义，写出规范，这种规范适合自动化分析。根据语义写出规范，就能就能检查规范是否一致，是否含有冲突，是否有疏漏进行检查。

2.2 语法
-------

>正如我们所料，能说明如何把一种编程语言的语法与这个语法暗含的语义对应起来的唯一正途并不存在。实际上，关于程序的含义有几种不同的研究方法，它们都在形式化 (formality)、 抽 象 度(abstraction)、 可 表 达 性(expressiveness) 和 实 际 效 率(efficiency) 之间做了权衡。在接下来的几节里，我们将看到这些主要的形式化方法，并了解它们之间的联系。

语法是规则，描述了什么样的字符串才是有效的程序。作者说如何将语言的语法对语法暗含的语义对应起来的”唯一正途“并不存在。这意味着这样的转换过程并不是很容易正确的完成的。

2.3操作语义
---------
>有了操作语义，我们可以朝着严谨而准确地研究语言中特定结构的目标前进了。用英语写 成的语言规范可能暗藏着二义性，并且可能遗漏边缘情况，但一个形式化的操作性规范不 会如此，为了令人信服地传达语言的行为，它必须明确而且无二义性。

操作语义描述了程序的运行，捕捉编程语言的含义。“令人信服的传达语言的行为“

### 2.3.1 小步语义
>把如何进行每一小步的规约写成形式化规则，这个非形式化的过程就可以转换成一个操 作语义。这些规则本身需要用某种语言(元语言)写下来，而这种语言通常是数学符号。

- 小步规约 - 形式化规则
- 非形式化过程 - 操作语义
- 规则 - 元语言

>我们不会试图直接理解这种形式化的符号，而是研究如何用 Ruby 编写同样的推导规则。 对程序员来说使用 Ruby 做元语言更容易理解，而且这样还有一个优点，就是这些规则可 以执行，我们能看到它们是如何工作的。

使用Ruby编写推导规则，容易理解，可以执行，但是却是用一种复杂的语言来解释简单的语言！

1. 表达式

>首先来研究一下Simple语言中表达式的语义。规则将作用于这些表达式的抽象语法树，所以我们必须把Simple表达式表示成 Ruby 对象。

如何描述一个表达式的语义？表达式先用Ruby对象表示出来，然后将语义规则作用在其上。

>在实现规约本身之前，我们先要区分什么样的表达式能规约，什么样的表达式不能规约。

这样才能终止。

>如果加法左边的参数能够规约，就规约左边的参数;如果加法左边的参数不能规约，但是右边的参数可以规约，就规约右边的参数;如果两边都不能规约，它们应该都是数字了，就把它们加到一起。

这定义了一个加法表达式的规约方式，通过不断进行规约直到不能规约为止。

>我们通过实现能对一种语言求值的虚拟机来定义它的操作 语义。虚拟机当前的状态就是当前的表达式，而机器的行为是由一个规则集合来描述的， 这个规则集合负责管理机器运行时的状态切换。

将规约的算法写成一个虚拟机，就能自动进行规约，状态是当前表达式，状态间的转移由规则集合或者说语义来描述。

>为了能规约一个变量，抽象机器不仅仅需要存储当前表达式，还要存储从变量名称到它 们值的映射——环境(environment)。

所以如果要为自己设计的编程语言加入变量的话，需要变量名称到值得映射。我们现在用的编程语言是怎么处理这种映射的呢？

2. 语句

>这个约束帮助我们强化了表达式和语句的区别。对于表达式，把一个环境传 递给 #reduce，然后得到一个规约了的表达式;因为没有返回一个新的环境， 所以很明显规约一个表达式不会改变环境。对于语句，我们将用当前的环境 调用 #reduce，然后得到一个新的环境，这表明规约一个语句会对环境有影 响。(换句话说，Simple 小步语义的结构告诉我们:Simple 的表达式是纯净 无害的，而它的语句不是这样。

表达式是”纯净无害的“，估计原文是no side effects吧，联想前两天看的ANF，这个表达式就是原子表达式，对环境没有改变，同时语句可以认为是复杂表达式，此时需要更新环境。在这里环境用了一个键值对搞定，但是在OCaml中，就是let binds的嵌套了。